import { HashInput } from 'o1js/dist/node/lib/circuit-value';
import { Field } from 'o1js/dist/node/lib/core';
import { Provable } from 'o1js/dist/node/lib/provable';
export { Poseidon, TokenSymbol };
export { ProvableHashable, HashInput, HashHelpers, emptyHashWithPrefix, hashWithPrefix, salt, packToFields, emptyReceiptChainHash, hashConstant, isHashable, };
type Hashable<T> = {
    toInput: (x: T) => HashInput;
    empty: () => T;
};
type ProvableHashable<T> = Provable<T> & Hashable<T>;
declare class Sponge {
    #private;
    constructor();
    absorb(x: Field): void;
    squeeze(): Field;
}
declare const Poseidon: {
    hash(input: Field[]): import("o1js/dist/node/lib/field").Field;
    update(state: [Field, Field, Field], input: Field[]): [import("o1js/dist/node/lib/field").Field, import("o1js/dist/node/lib/field").Field, import("o1js/dist/node/lib/field").Field];
    hashWithPrefix(prefix: string, input: Field[]): import("o1js/dist/node/lib/field").Field;
    initialState(): [Field, Field, Field];
    hashToGroup(input: Field[]): {
        x: import("o1js/dist/node/lib/field").Field;
        y: {
            x0: import("o1js/dist/node/lib/field").Field;
            x1: import("o1js/dist/node/lib/field").Field;
        };
    };
    /**
     * Hashes a provable type efficiently.
     *
     * ```ts
     * let skHash = Poseidon.hashPacked(PrivateKey, secretKey);
     * ```
     *
     * Note: Instead of just doing `Poseidon.hash(value.toFields())`, this
     * uses the `toInput()` method on the provable type to pack the input into as few
     * field elements as possible. This saves constraints because packing has a much
     * lower per-field element cost than hashing.
     */
    hashPacked<T>(type: Hashable<T>, value: T): import("o1js/dist/node/lib/field").Field;
    Sponge: typeof Sponge;
};
declare function hashConstant(input: Field[]): import("o1js/dist/node/lib/field").Field;
declare const HashHelpers: {
    salt: (prefix: string) => import("o1js/dist/node/lib/field").Field[];
    emptyHashWithPrefix: (prefix: string) => import("o1js/dist/node/lib/field").Field;
    hashWithPrefix: (prefix: string, input: import("o1js/dist/node/lib/field").Field[]) => import("o1js/dist/node/lib/field").Field;
};
declare let salt: (prefix: string) => import("o1js/dist/node/lib/field").Field[], emptyHashWithPrefix: (prefix: string) => import("o1js/dist/node/lib/field").Field, hashWithPrefix: (prefix: string, input: import("o1js/dist/node/lib/field").Field[]) => import("o1js/dist/node/lib/field").Field;
/**
 * Convert the {fields, packed} hash input representation to a list of field elements
 * Random_oracle_input.Chunked.pack_to_fields
 */
declare function packToFields({ fields, packed }: HashInput): import("o1js/dist/node/lib/field").Field[];
declare function isHashable<T>(obj: any): obj is Hashable<T>;
declare const TokenSymbol_base: (new (value: {
    symbol: string;
    field: import("o1js/dist/node/lib/field").Field;
}) => {
    symbol: string;
    field: import("o1js/dist/node/lib/field").Field;
}) & {
    _isStruct: true;
} & Provable<{
    symbol: string;
    field: import("o1js/dist/node/lib/field").Field;
}> & {
    toInput: (x: {
        symbol: string;
        field: import("o1js/dist/node/lib/field").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/field").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field").Field, number][] | undefined;
    };
    toJSON: (x: {
        symbol: string;
        field: import("o1js/dist/node/lib/field").Field;
    }) => string;
    fromJSON: (x: string) => {
        symbol: string;
        field: import("o1js/dist/node/lib/field").Field;
    };
    empty: () => {
        symbol: string;
        field: import("o1js/dist/node/lib/field").Field;
    };
};
declare class TokenSymbol extends TokenSymbol_base {
    static from(symbol: string): TokenSymbol;
}
declare function emptyReceiptChainHash(): import("o1js/dist/node/lib/field").Field;
